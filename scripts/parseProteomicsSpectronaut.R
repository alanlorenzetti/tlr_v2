# alorenzetti 202007

# description ####
# this script will parse proteomics abundance data
# generated by Spectronaut software

# loading libs ####
source("scripts/loadingLibs.R")

# loading files ####
file = "data/Halo_WholeLysate_analysis_HaloIonLibraryVNG_merged_final_2018-04-07_SW100_Protein_Report_20200731.xls"
file2 = "data/Halo_Ribo_analysis_HaloIonLibraryVNG_merged_final_2018-04-07_SW100_Protein_Report.xls"

# they will throw a warning saying
# cols were parsed as.character
# but we ll deal with that later
spectro1 = read_delim(file = file, delim = "\t")
spectro2 = read_delim(file = file2, delim = "\t")

# in this version I am going to use
# only the lysate fraction
spectro = spectro1

# full join of both dataframes
#spectro = full_join(spectro1, spectro2, by = "PG.ProteinAccessions")

# wrangling ####
# adjusting colnames
colnames(spectro)[-1] = sub("^\\[.* ", "", colnames(spectro)[-1])
colnames(spectro)[-1] = sub("^.*_?(BR[1-3])(TP[1-4]).*_.*_.*_(r0[1-3]).*$",
                            "\\2_\\1_\\3",
                            colnames(spectro)[-1],
                            perl = T)
colnames(spectro)[-1] = paste0(rep("lysate_", 36),
                               colnames(spectro)[-1])
colnames(spectro)[1] = "locus_tag"

# removing first entry line
spectro = spectro[-1, ]

# warnings will be thrown due to
# missing entries ("Filtered" value)
spectro = spectro %>%
  mutate_at(.vars = vars(contains("BR")),
            .funs = as.numeric)

# selection of entries ####
# we have to filter the table due to the existence
# of peptides matching more than one protein
# our simplification is:
# the members of a protein group can exist in
# the form of an individual observation
# if only one member of a protein group exists individually
# protein group values and individual protein values
# are tallied up;
# if more than two members of a protein group exist individually
# the protein group is discarded
# if no member of a protein group exists individually
# the protein group is kept (first locus_tag is preserved)

# finding out solos and protein groups
solo = spectro %>% 
  filter(!str_detect(locus_tag, ","))
pg = spectro %>% 
  filter(str_detect(locus_tag, ","))

ex = NULL
pgvspg = NULL
for(i in 1:dim(pg)[1]){
  curline = pg$locus_tag[i] %>% 
    str_split(pattern = ",") %>% 
    unlist()
  for(j in 1:length(curline)){
    ex[j] = curline[j] %in% solo$locus_tag
    names(ex)[j] = curline[j]
  }
  if(sum(ex) == 0){pass = "pass0"; repres = names(ex)[1]}
  if(sum(ex) == 1){pass = "pass1"; repres = names(which(ex == TRUE))}
  if(sum(ex) > 1){pass = "fail"; repres = NA_character_} 
  
  y = 1:dim(pg)[1]
  for(k in y[-i]){
    curpg = pg$locus_tag[k] %>% 
      str_split(pattern = ",") %>% 
      unlist()
    pgvspg = c(pgvspg, sum(names(ex) %in% curpg))
  }
  
  npg = sum(pgvspg > 0)
  if(sum(pgvspg) == 0){passpg = "pass"}
  if(sum(pgvspg) > 0){passpg = paste0("fail", npg)}
  
  if((pass == "pass0" | pass == "pass1") & passpg == "pass"){
    pg$locus_tag[i] = repres
  }

  ex = NULL
  pgvspg = NULL
}

# filtering out those protein groups
# that failed our simplification
pg = pg %>% 
  filter(!str_detect(locus_tag, ","))

# VNG5030G (GvpA) and VNG5033G (GvpN) were manually included
# since they are protein groups contained within
# another protein group but satisfy the nonambiguity criterion
# e.g. the protein groups come from isoforms of GvpA1a, GvpA1b, and GvpA2
gvpAN = spectro %>% 
  filter(str_detect(string = locus_tag, pattern = "^VNG5030G|^VNG5033G")) %>% 
  mutate(locus_tag = str_replace(string = locus_tag, pattern = ",.*", replacement = ""))

# unifying individual proteins to
# simplified protein groups
soloPlusSPG = bind_rows(solo, pg, gvpAN) %>% 
  arrange(locus_tag) %>% 
  group_by(locus_tag) %>%
  dplyr::summarise(across(.cols = starts_with("lysate"),
                          .fns = ~ sum(.x, na.rm = T))) %>% 
  ungroup() %>% 
  dplyr::mutate(across(.cols = starts_with("lysate"),
                       .fns = ~ case_when(.x == 0 ~ NA_real_,
                                          TRUE ~ as.numeric(.x))))

spectro = soloPlusSPG

# pivoting data frame
# we will take run means and annotate number of runs used
# I would say using six (of nine) observations is fair enough
spectroLong = spectro %>%
  pivot_longer(cols = contains("BR"),
               names_to = c("libType", "timepoint", "bioRep", "run"),
               names_sep = "_",
               values_to = "abundance") %>% 
  group_by(locus_tag, libType, timepoint) %>% 
  summarise(nruns = 9 - sum(is.na(abundance)),
            mean_abundance = mean(abundance, na.rm = T),
            se_abundance = (sd(abundance, na.rm = T) / sqrt(nruns))) %>% 
  mutate(mean_abundance = case_when(is.nan(mean_abundance) ~ NA_real_,
                                    TRUE ~ as.numeric(mean_abundance)),
         se_abundance = case_when(is.nan(se_abundance) ~ NA_real_,
                                  TRUE ~ as.numeric(se_abundance))) %>% 
  ungroup() %>% 
  filter(nruns >= 6)

# using longer dataframe, I will
# create a wider version to be able
# to plot heat maps using ComplxHeatmaps
# and furthermore to unify it with
# RNA-Seq data
spectroWide = spectroLong %>% 
  dplyr::select(-nruns) %>% 
  pivot_wider(names_from = c("libType", "timepoint"),
              names_sep = "_",
              values_from = c("mean_abundance", "se_abundance"))
colnames(spectroWide)[-1] = sub("abundance_", "abundance_protein_", colnames(spectroWide)[-1])

# adjusting locus_tags
# according to dictProd
# "VNG0212H"  "VNG0606G"  "VNG0779C"  "VNG0780H"  "VNG1585Cm"  "VNG5138C"
# don't have a matching sequence in pfeiLocusTag
# those are going to be removed
spectroWide = left_join(spectroWide, dictProd, by = c("locus_tag" = "query_id"))

remove = spectroWide$locus_tag[is.na(spectroWide$subject_id) %>% which()]
spectroWide = spectroWide[!(spectroWide$locus_tag %in% remove),] %>% 
  mutate(locus_tag = subject_id) %>% 
  dplyr::select(-subject_id, -product.y)

# exploratory plots #####
# plotting densities
# normalization doesnt seem necessary
# distributions are quite similar
# and look like poisson
# ggplot(spectroLong,
#        aes(x = log10(mean_abundance),
#            color = timepoint)) +
#   geom_density() +
#   facet_grid(~libType)

# generating a heat map to check
# sample grouping
# colfunct = circlize::colorRamp2(breaks = c(0,3,6), colors = viridis(3))
# Heatmap(spectro[ ,-1] %>% drop_na() %>% as.matrix() %>% log10(),
#         col = colfunct)
# 
# # timepoint grouping
# Heatmap(spectroWide %>% dplyr::select(-locus_tag, -contains("se")) %>%
#           drop_na() %>% as.matrix() %>% log10(),
#         col = colfunct)
